
/* --------------------------------------------------------
	Generated by T4 ADO.NET

		Generation begin: 11/07/2012 22:18:44
		Generate by: Kazuhiko on KAZUK-DEV

 ------------------------------------------------------- */
using System;
using System.Data.SqlClient;
using System.Collections.Generic;
// ReSharper disable CheckNamespace
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantNameQualifier

namespace T4Adonet.Samples
{
   public partial class TablesCommand 
       : IDisposable
   {
       private const string CommandText = @"select * from sys.tables t where t.name=@tableName
select * from sys.columns
";
       private readonly  SqlCommand _sqlCommand;
       private static readonly  System.Collections.Concurrent.ConcurrentStack<SqlCommand> _preparedCommand
           =new System.Collections.Concurrent.ConcurrentStack<SqlCommand>();
       private readonly  SqlParameter _param_tableName;
       public TablesCommand(SqlConnection conn)
       {
           SqlCommand command;
           if( !_preparedCommand.TryPop( out command ) )
           {
               _sqlCommand = new SqlCommand( CommandText, conn ); 		
               _param_tableName = new SqlParameter();
               _sqlCommand.Parameters.AddRange( 
                   new [] 
                   {
                       _param_tableName
                   } );
           }
           else
           {
               command.Connection = conn;
               _param_tableName= command.Parameters[0];
               _sqlCommand = command;
           }
       }
       public void Dispose()
       {
           Dispose(true);
       }
       ~TablesCommand()
       {
           Dispose(false);
       }
       private  bool _disposed;
       public void Dispose(bool disposing)
       {
           if( _disposed ) return;
           if( disposing )
           {
           	_sqlCommand.Connection = null;
           	_preparedCommand.Push( _sqlCommand );
           	GC.SuppressFinalize( this );
           }
           _disposed = true;
       }
       private void ThrowIfDisposed()
       {
           if( _disposed ) throw new ObjectDisposedException(GetType().FullName);
       }
       public SqlDataReader Execute(String tableName)
       {
           ThrowIfDisposed();
           _param_tableName.Value = tableName;
           return _sqlCommand.ExecuteReader( );
       }
       public struct ResultSet0
       {
           public StringBuffer Name { get; internal set; }
           public System.Int32 ObjectId { get; internal set; }
           public System.Int32? PrincipalId { get; internal set; }
           public System.Int32 SchemaId { get; internal set; }
           public System.Int32 ParentObjectId { get; internal set; }
           public StringBuffer Type { get; internal set; }
           public StringBuffer TypeDesc { get; internal set; }
           public System.DateTime CreateDate { get; internal set; }
           public System.DateTime ModifyDate { get; internal set; }
           public System.Boolean IsMsShipped { get; internal set; }
           public System.Boolean IsPublished { get; internal set; }
           public System.Boolean IsSchemaPublished { get; internal set; }
           public System.Int32 LobDataSpaceId { get; internal set; }
           public System.Int32? FilestreamDataSpaceId { get; internal set; }
           public System.Int32 MaxColumnIdUsed { get; internal set; }
           public System.Boolean LockOnBulkLoad { get; internal set; }
           public System.Boolean? UsesAnsiNulls { get; internal set; }
           public System.Boolean? IsReplicated { get; internal set; }
           public System.Boolean? HasReplicationFilter { get; internal set; }
           public System.Boolean? IsMergePublished { get; internal set; }
           public System.Boolean? IsSyncTranSubscribed { get; internal set; }
           public System.Boolean HasUncheckedAssemblyData { get; internal set; }
           public System.Int32? TextInRowLimit { get; internal set; }
           public System.Boolean? LargeValueTypesOutOfRow { get; internal set; }
           public System.Boolean? IsTrackedByCdc { get; internal set; }
           public System.Byte? LockEscalation { get; internal set; }
           public StringBuffer LockEscalationDesc { get; internal set; }
           public System.Boolean? IsFiletable { get; internal set; }
       }
       public IEnumerable<ResultSet0> Fetch0( SqlDataReader reader )
       {
           while( reader.Read() )
           {
               var record= new ResultSet0 
               {
                   Name=GetBufferFor( reader, 0 ),
                   ObjectId=reader.GetInt32(1),
                   PrincipalId= reader.IsDBNull(2)
                       ? default(System.Int32)
                       : reader.GetInt32(2),
                   SchemaId=reader.GetInt32(3),
                   ParentObjectId=reader.GetInt32(4),
                   Type=GetBufferFor( reader, 5 ),
                   TypeDesc= reader.IsDBNull( 6 )
                       ? default( StringBuffer )
                       : GetBufferFor( reader, 6 ),
                   CreateDate=reader.GetDateTime(7),
                   ModifyDate=reader.GetDateTime(8),
                   IsMsShipped=reader.GetBoolean(9),
                   IsPublished=reader.GetBoolean(10),
                   IsSchemaPublished=reader.GetBoolean(11),
                   LobDataSpaceId=reader.GetInt32(12),
                   FilestreamDataSpaceId= reader.IsDBNull(13)
                       ? default(System.Int32)
                       : reader.GetInt32(13),
                   MaxColumnIdUsed=reader.GetInt32(14),
                   LockOnBulkLoad=reader.GetBoolean(15),
                   UsesAnsiNulls= reader.IsDBNull(16)
                       ? default(System.Boolean)
                       : reader.GetBoolean(16),
                   IsReplicated= reader.IsDBNull(17)
                       ? default(System.Boolean)
                       : reader.GetBoolean(17),
                   HasReplicationFilter= reader.IsDBNull(18)
                       ? default(System.Boolean)
                       : reader.GetBoolean(18),
                   IsMergePublished= reader.IsDBNull(19)
                       ? default(System.Boolean)
                       : reader.GetBoolean(19),
                   IsSyncTranSubscribed= reader.IsDBNull(20)
                       ? default(System.Boolean)
                       : reader.GetBoolean(20),
                   HasUncheckedAssemblyData=reader.GetBoolean(21),
                   TextInRowLimit= reader.IsDBNull(22)
                       ? default(System.Int32)
                       : reader.GetInt32(22),
                   LargeValueTypesOutOfRow= reader.IsDBNull(23)
                       ? default(System.Boolean)
                       : reader.GetBoolean(23),
                   IsTrackedByCdc= reader.IsDBNull(24)
                       ? default(System.Boolean)
                       : reader.GetBoolean(24),
                   LockEscalation= reader.IsDBNull(25)
                       ? default(System.Byte)
                       : reader.GetByte(25),
                   LockEscalationDesc= reader.IsDBNull( 26 )
                       ? default( StringBuffer )
                       : GetBufferFor( reader, 26 ),
                   IsFiletable= reader.IsDBNull(27)
                       ? default(System.Boolean)
                       : reader.GetBoolean(27),
               };
               yield return record;
               ReleaseBuffer( record.Name);
               ReleaseBuffer( record.Type);
               ReleaseBuffer( record.TypeDesc);
               ReleaseBuffer( record.LockEscalationDesc);
           }
       }
       public struct ResultSet1
       {
           public System.Int32 ObjectId { get; internal set; }
           public StringBuffer Name { get; internal set; }
           public System.Int32 ColumnId { get; internal set; }
           public System.Byte SystemTypeId { get; internal set; }
           public System.Int32 UserTypeId { get; internal set; }
           public System.Int16 MaxLength { get; internal set; }
           public System.Byte Precision { get; internal set; }
           public System.Byte Scale { get; internal set; }
           public StringBuffer CollationName { get; internal set; }
           public System.Boolean? IsNullable { get; internal set; }
           public System.Boolean IsAnsiPadded { get; internal set; }
           public System.Boolean IsRowguidcol { get; internal set; }
           public System.Boolean IsIdentity { get; internal set; }
           public System.Boolean IsComputed { get; internal set; }
           public System.Boolean IsFilestream { get; internal set; }
           public System.Boolean? IsReplicated { get; internal set; }
           public System.Boolean? IsNonSqlSubscribed { get; internal set; }
           public System.Boolean? IsMergePublished { get; internal set; }
           public System.Boolean? IsDtsReplicated { get; internal set; }
           public System.Boolean IsXmlDocument { get; internal set; }
           public System.Int32 XmlCollectionId { get; internal set; }
           public System.Int32 DefaultObjectId { get; internal set; }
           public System.Int32 RuleObjectId { get; internal set; }
           public System.Boolean? IsSparse { get; internal set; }
           public System.Boolean? IsColumnSet { get; internal set; }
       }
       public IEnumerable<ResultSet1> Fetch1( SqlDataReader reader )
       {
           while( reader.Read() )
           {
               var record= new ResultSet1 
               {
                   ObjectId=reader.GetInt32(0),
                   Name= reader.IsDBNull( 1 )
                       ? default( StringBuffer )
                       : GetBufferFor( reader, 1 ),
                   ColumnId=reader.GetInt32(2),
                   SystemTypeId=reader.GetByte(3),
                   UserTypeId=reader.GetInt32(4),
                   MaxLength=reader.GetInt16(5),
                   Precision=reader.GetByte(6),
                   Scale=reader.GetByte(7),
                   CollationName= reader.IsDBNull( 8 )
                       ? default( StringBuffer )
                       : GetBufferFor( reader, 8 ),
                   IsNullable= reader.IsDBNull(9)
                       ? default(System.Boolean)
                       : reader.GetBoolean(9),
                   IsAnsiPadded=reader.GetBoolean(10),
                   IsRowguidcol=reader.GetBoolean(11),
                   IsIdentity=reader.GetBoolean(12),
                   IsComputed=reader.GetBoolean(13),
                   IsFilestream=reader.GetBoolean(14),
                   IsReplicated= reader.IsDBNull(15)
                       ? default(System.Boolean)
                       : reader.GetBoolean(15),
                   IsNonSqlSubscribed= reader.IsDBNull(16)
                       ? default(System.Boolean)
                       : reader.GetBoolean(16),
                   IsMergePublished= reader.IsDBNull(17)
                       ? default(System.Boolean)
                       : reader.GetBoolean(17),
                   IsDtsReplicated= reader.IsDBNull(18)
                       ? default(System.Boolean)
                       : reader.GetBoolean(18),
                   IsXmlDocument=reader.GetBoolean(19),
                   XmlCollectionId=reader.GetInt32(20),
                   DefaultObjectId=reader.GetInt32(21),
                   RuleObjectId=reader.GetInt32(22),
                   IsSparse= reader.IsDBNull(23)
                       ? default(System.Boolean)
                       : reader.GetBoolean(23),
                   IsColumnSet= reader.IsDBNull(24)
                       ? default(System.Boolean)
                       : reader.GetBoolean(24),
               };
               yield return record;
               ReleaseBuffer( record.Name);
               ReleaseBuffer( record.CollationName);
           }
       }
       public struct StringBuffer
       {
           public int length;
           public char[] buffer;
       }
       
       private const int bufferStep = 64;
       private static readonly Dictionary<int,Stack<char[]>> _reservedBuffers
           = new Dictionary<int,Stack<char[]>>();
       
       private StringBuffer GetBufferFor( SqlDataReader reader, int ordinal )
       {
           var length = reader.GetChars( ordinal,0,null,0,0 );
           var bufferBlock =(int) length / bufferStep;
           Stack<char[]> buffers;
           lock( _reservedBuffers ) 
           {
               if( !_reservedBuffers.TryGetValue( bufferBlock,out buffers ) )
               {
                   buffers = new Stack<char[]>();
                   _reservedBuffers.Add( bufferBlock, buffers );
               }
           }
           char[] buffer;
           lock( buffers ) 
           {
               buffer = buffers.Count!=0 
                   ? buffers.Pop() 
                   : new char[(bufferBlock+1)*bufferStep];
           }
           reader.GetChars( ordinal,0,buffer,0,(int)length );
           return new StringBuffer() { 
               length = (int) length, 
               buffer = buffer };
       }
       
       private void ReleaseBuffer(StringBuffer buffer)
       {
           if( buffer.buffer==null ) return;
       
           var bufferBlock = buffer.length / bufferStep;
           Stack<char[]> buffers;
           lock( _reservedBuffers )
           {
               if( !_reservedBuffers.TryGetValue( bufferBlock,out buffers ) )
               {
                   buffers = new Stack<char[]>();
                   _reservedBuffers.Add( bufferBlock, buffers );
               }
           }
       	lock( buffers )
       	{
       		buffers.Push( buffer.buffer );
       	}
       }
   }
}

