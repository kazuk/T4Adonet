<#@ template debug="false" hostspecific="false"  inherits="TransformationBase" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ include file="TTCSharpUtility.tt" #>
<#@ output extension=".cs" #>
<#
	var connectionString = @"Data Source=(LocalDB)\v11.0;AttachDbFilename=C:\Users\Kazuhiko\Documents\GitHub\T4Adonet\Kazuk.T4Adonet\TargetDb.mdf;Integrated Security=True";

	var literalContainer = new Dictionary<string,string>();
	
	using( ToLiteral(literalContainer, "TablesQuery") ) {#>
select * from sys.tables t where t.name=@tableName
select * from sys.columns
<#	}
	
	var commands = new []{
		new SelectCommandDefinition {
			ClassName = "TablesCommand",
			CommandText = literalContainer["TablesQuery"],
			Parameters = new ParameterNameAndTypeList {
				{ "tableName", typeof(string) }
			}
		},
	};

	var namespaceName = "T4Adonet.Samples";

	GCOptimizeForStringColumn = 
		(className, resultSetIndex, columnName) => true;

#>
/* --------------------------------------------------------
	Generated by T4 ADO.NET

		Generation begin: <#= DateTime.Now#>
		Generate by: <#=System.Environment.UserName #> on <#=System.Environment.MachineName#>

 ------------------------------------------------------- */
using System;
using System.Data.SqlClient;
using System.Collections.Generic;
// ReSharper disable CheckNamespace
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantNameQualifier

<#
	using( BeginNamespace( namespaceName ) )
	{
		foreach( var cmdDef in commands )
		{
			using( SqlConnection conn = new SqlConnection( connectionString ) )
			{
				using(var cls=BeginClass( cmdDef.ClassName, @partial: true, interfaces: new[]{ "IDisposable" } ) )
				{
					GenerateCommandClassContent( cmdDef, cls );
					conn.Open();
					SqlCommand cmd = new SqlCommand( cmdDef.CommandText,conn );
					// スキーマだけほしいので null パラメータを使ってコマンドを投げています
					foreach( var param in cmdDef.Parameters )
					{
						cmd.Parameters.AddWithValue( param.Name, null );
					}
					cmd.CommandType = CommandType.Text;
					bool generateBufferManager = false;
					using( var reader = cmd.ExecuteReader( CommandBehavior.SchemaOnly ) )
					{
						int resultCnt =0;
						do {
							var schema = reader.GetSchemaTable();
							GenerateResultSetStruct( cmdDef.ClassName, schema, resultCnt );
							generateBufferManager |= GenerateFetcher(cmdDef.ClassName, schema, resultCnt);
							resultCnt++;
						} while( reader.NextResult() );
						if( resultCnt==1 )
						{
#>
		public IEnumerable<ResultSet0> Fetch( SqlDataReader reader )
		{
			return Fetch0( reader );
		}
<#
						}
					}
					if( generateBufferManager ) {
#>
public struct StringBuffer
{
    public int length;
    public char[] buffer;
}

private const int bufferStep = 64;
private static readonly Dictionary<int,Stack<char[]>> _reservedBuffers
    = new Dictionary<int,Stack<char[]>>();

private StringBuffer GetBufferFor( SqlDataReader reader, int ordinal )
{
    var length = reader.GetChars( ordinal,0,null,0,0 );
    var bufferBlock =(int) length / bufferStep;
    Stack<char[]> buffers;
    lock( _reservedBuffers ) 
    {
        if( !_reservedBuffers.TryGetValue( bufferBlock,out buffers ) )
        {
            buffers = new Stack<char[]>();
            _reservedBuffers.Add( bufferBlock, buffers );
        }
    }
    char[] buffer;
    lock( buffers ) 
    {
        buffer = buffers.Count!=0 
            ? buffers.Pop() 
            : new char[(bufferBlock+1)*bufferStep];
    }
    reader.GetChars( ordinal,0,buffer,0,(int)length );
    return new StringBuffer() { 
        length = (int) length, 
        buffer = buffer };
}

private void ReleaseBuffer(StringBuffer buffer)
{
    if( buffer.buffer==null ) return;

    var bufferBlock = buffer.length / bufferStep;
    Stack<char[]> buffers;
    lock( _reservedBuffers )
    {
        if( !_reservedBuffers.TryGetValue( bufferBlock,out buffers ) )
        {
            buffers = new Stack<char[]>();
            _reservedBuffers.Add( bufferBlock, buffers );
        }
    }
	lock( buffers )
	{
		buffers.Push( buffer.buffer );
	}
}
<#
					}
				}
			}
		}
	}
#>

<#+
	Func<string,int,string,bool> GCOptimizeForStringColumn { get; set; }

	public class SelectCommandDefinition
	{
		public string ClassName;
		public string CommandText;
		public IEnumerable<ParameterNameAndType> Parameters;
	}

	public class ParameterNameAndType
	{
		readonly string _name;
		readonly Type _type;

		public ParameterNameAndType( string name, Type type)
		{
			_name = name;
			_type = type;
		}

		public string Name { get { return _name; } }
		public Type Type { get { return _type; } }
	}

	public class ParameterNameAndTypeList : List<ParameterNameAndType>
	{
		public void Add( string parameterName, Type type )
		{
			Add( new ParameterNameAndType( parameterName, type ) );
		}
	}

	void GenerateCommandClassContent( SelectCommandDefinition cmdDef, ClassContext cls )
	{
		DeclareConst( "CommandText", "string", ()=>{
			using( BeginDisableIndent() ) {
				#><#=ToVerbatimString(cmdDef.CommandText)#><#+ 
			} } );
		DeclareField( "_sqlCommand", "SqlCommand", @readonly:true );
		DeclareField( "_preparedCommand", "System.Collections.Concurrent.ConcurrentStack<SqlCommand>",
			@readonly: true, 
			@static:true, 
			initializer :
				()=> {#>new System.Collections.Concurrent.ConcurrentStack<SqlCommand>()<#+} );

		foreach( var param in cmdDef.Parameters )
		{
			DeclareField( "_param_"+param.Name, "SqlParameter", @readonly:true );
		}

						DeclareConstractor( cls, 
					parameters: new[] { new { Name="conn", Type="SqlConnection" } },
					body: () => {
#>
SqlCommand command;
if( !_preparedCommand.TryPop( out command ) )
{
    _sqlCommand = new SqlCommand( CommandText, conn ); 		
<#+						Generate( cmdDef.Parameters, param=>{#>
    _param_<#=param.Name#> = new SqlParameter();
<#+							});#>
    _sqlCommand.Parameters.AddRange( 
        new [] 
        {
<#+						Generate( cmdDef.Parameters, ", ", param=>{#>
            _param_<#=param.Name#>
<#+							});#>
        } );
}
else
{
    command.Connection = conn;
<#+
						Generate( cmdDef.Parameters, (param,index)=>{#>
    _param_<#=param.Name#>= command.Parameters[<#=index#>];
<#+							});#>
    _sqlCommand = command;
}
<#+				} );
				DeclareMethod( "Dispose", "void",access: "public",
					body: ()=>{#>
Dispose(true);
<#+					});

				DeclareFinalizer( cls,
					body: ()=>{#>
Dispose(false);
<#+					});
				DeclareField( "_disposed", "bool" );
				DeclareMethod( "Dispose", "void",
					parameters: new[] { new { Name="disposing",Type="bool" } },
					body: ()=>{
#>
if( _disposed ) return;
if( disposing )
{
	_sqlCommand.Connection = null;
	_preparedCommand.Push( _sqlCommand );
	GC.SuppressFinalize( this );
}
_disposed = true;
<#+					});
				DeclareMethod( "ThrowIfDisposed", "void", access:"private",
					body: ()=>{
#>
if( _disposed ) throw new ObjectDisposedException(GetType().FullName);
<#+					});
				DeclareMethod( "Execute", "SqlDataReader", 
					parameters: cmdDef.Parameters.Select(p=> new { Name=p.Name, Type=p.Type.Name }),
					body: ()=>{
#>
ThrowIfDisposed();
<#+
						Generate( cmdDef.Parameters,param=>{#>
_param_<#=param.Name#>.Value = <#=param.Name#>;
<#+
							});
#>
return _sqlCommand.ExecuteReader( );
<#+					});

	}


	public bool GenerateFetcher( string className,  DataTable schema, int resultCnt )
	{
		bool generateBufferManager = false;
#>
public IEnumerable<ResultSet<#=resultCnt#>> Fetch<#=resultCnt#>( SqlDataReader reader )
{
    while( reader.Read() )
    {
        var record= new ResultSet<#=resultCnt#> 
        {
<#+
		foreach( DataRow row in schema.Rows )
		{
			if( ((Type)row["DataType"])==typeof(string) 
				&& GCOptimizeForStringColumn( className, resultCnt, (string)row["ColumnName"] ) )
			{
				generateBufferManager = true;
				if( !((bool)row["AllowDbNull"]) )
				{
#>
            <#=ToPropertyName( (string) row["ColumnName"] )#>=GetBufferFor( reader, <#=row["ColumnOrdinal"]#> ),
<#+
				}
				else
				{
#>
            <#=ToPropertyName( (string) row["ColumnName"] )#>= reader.IsDBNull( <#=row["ColumnOrdinal"]#> )
                ? default( StringBuffer )
                : GetBufferFor( reader, <#=row["ColumnOrdinal"]#> ),
<#+
				}
			} 
			else {
				if( !((bool)row["AllowDbNull"]) )
				{
#>
            <#=ToPropertyName( (string) row["ColumnName"] )#>=reader.<#= GetterOf((Type)row["DataType"])#>(<#=row["ColumnOrdinal"]#>),
<#+
				}
				else
				{
#>
            <#=ToPropertyName( (string) row["ColumnName"] )#>= reader.IsDBNull(<#=row["ColumnOrdinal"]#>)
                ? default(<#=row["DataType"]#>)
                : reader.<#= GetterOf((Type)row["DataType"])#>(<#=row["ColumnOrdinal"]#>),
<#+
				}
			}
		}
#>
        };
        yield return record;
<#+
		if( generateBufferManager ) 
		{
			foreach( DataRow row in schema.Rows )
			{
				if( ((Type)row["DataType"])==typeof(string) 
					&& GCOptimizeForStringColumn( className, resultCnt, (string)row["ColumnName"] ) )
				{
#>
        ReleaseBuffer( record.<#=ToPropertyName( (string) row["ColumnName"] )#>);
<#+
				}
			}
		}
#>
    }
}
<#+
		return generateBufferManager;
	}

	public void GenerateResultSetStruct( string className, DataTable schema,int resultCnt )
	{
#>
public struct ResultSet<#=resultCnt#>
{
<#+
		foreach( DataRow row in schema.Rows )
		{
			if( ((Type)row["DataType"])==typeof(string) 
				&& GCOptimizeForStringColumn( className, resultCnt, (string)row["ColumnName"] ) )
			{
#>
    public StringBuffer <#=ToPropertyName( (string) row["ColumnName"] )#> { get; internal set; }
<#+
			}
			else 
			{
				if( (bool)row["AllowDbNull"] && ((Type)row["DataType"])!=typeof(string) )
				{
#>
    public <#=row["DataType"]#>? <#=ToPropertyName( (string) row["ColumnName"] )#> { get; internal set; }
<#+
				}
				else
				{
#>
    public <#=row["DataType"]#> <#=ToPropertyName( (string) row["ColumnName"] )#> { get; internal set; }
<#+
				}
			}
		}
#>
}
<#+
	}

	// ToPropertyName : string -> string
	//  converts SQL column name to C# Property name
	// ex
	//  hoge -> Hoge, hoge_id -> HogeId,
	//  HOGE -> Hoge, HOGE_ID -> HogeId
	// remarks
	//  (null) -> NoName, ""-> NoName
	public string ToPropertyName( string columnName )
	{
		if( string.IsNullOrEmpty(columnName) ) return "NoName";

		var nameParts = columnName.Split('_');
		return string.Join( "",nameParts.Select( 
			s =>
				s.Length > 1 
					? char.ToUpper( s[0] ) + s.Substring(1).ToLower() 
					: char.ToUpper( s[0] ).ToString() ) );
	}

	public static bool IsValidGetterParam( System.Reflection.MethodInfo m )
	{
		var p = m.GetParameters();
		if( p.Count()!=1 ) return false;
		return p[0].ParameterType == typeof( int ) ;
	}

	static Dictionary<Type,System.Reflection.MethodInfo > _getMethods =
			typeof(SqlDataReader).GetMethods()
				.Where( m=>m.Name.StartsWith("Get") )
				.Where( m=>!m.Name.StartsWith("GetSql") )
				.Where( m=>IsValidGetterParam(m) )
				.Where( 
					m=>m.Name!="GetOrdinal" 
					&& m.Name!="GetFieldType" 
					&& m.Name!="GetDataTypeName" 
					&& m.Name!="GetName"
					&& m.Name!="GetProviderSpecificValue"
					&& m.Name!="GetProviderSpecificFieldType" )
				.ToDictionary( m=>m.ReturnType );

	// GetterOf : Type -> string
	//  gets SqlDataReader field getter method name for specific Type
	public string GetterOf( Type dataType )
	{
		return _getMethods[dataType].Name;
	}
#>