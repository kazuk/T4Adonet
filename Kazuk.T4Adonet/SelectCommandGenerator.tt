<#@ template debug="false" hostspecific="false"  inherits="TransformationBase" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ include file="TTCSharpUtility.tt" #>
<#@ output extension=".cs" #>
<#
	var connectionString = @"Data Source=(LocalDb)\v11.0;Initial Catalog=t4adonetTest;Integrated Security=True;Pooling=False";

	var literalContainer = new Dictionary<string,string>();
	
	using( ToLiteral(literalContainer, "TablesQuery") ) {#>
select * from sys.tables t where t.name=@tableName
select * from sys.columns
<#	}
	
	var commands = new []{
		new SelectCommandDefinition {
			ClassName = "TablesCommand",
			CommandText = literalContainer["TablesQuery"],
			Parameters = new ParameterNameAndTypeList {
				{ "tableName", typeof(string) , SqlDbType.VarChar }
			}
		},
	};

	var namespaceName = "T4Adonet.Samples";


#>
/* --------------------------------------------------------
	Generated by T4 ADO.NET

		Generation begin: <#= DateTime.Now#>
		Generate by: <#=System.Environment.UserName #> on <#=System.Environment.MachineName#>

 ------------------------------------------------------- */
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Collections.Concurrent;

// ReSharper disable CheckNamespace
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantNameQualifier

<#
	using( BeginNamespace( namespaceName ) )
	{
		foreach( var cmdDef in commands )
		{
			GenerateSelectCommand(cmdDef,connectionString);
		}
	}
#>

<#+
	void GenerateSelectCommand( SelectCommandDefinition cmdDef, string connectionString )
	{
		using( SqlConnection conn = new SqlConnection( connectionString ) )
		{
			using(var cls=BeginClass( cmdDef.ClassName, @partial: true, interfaces: new[]{ "IDisposable" } ) )
			{
				GenerateCommandClassContent( cmdDef, cls );
				conn.Open();
				SqlCommand cmd = new SqlCommand( cmdDef.CommandText,conn );
				// スキーマだけほしいので null パラメータを使ってコマンドを投げています
				foreach( var param in cmdDef.Parameters )
				{
					cmd.Parameters.AddWithValue( param.Name, null );
				}
				cmd.CommandType = CommandType.Text;
				using( var reader = cmd.ExecuteReader( CommandBehavior.SchemaOnly ) )
				{
					int resultCnt =0;
					do {
						var schema = reader.GetSchemaTable();
						GenerateResultSetStruct( cmdDef.ClassName, schema, resultCnt );
						GenerateFetcher(cmdDef.ClassName, schema, resultCnt);
						resultCnt++;
					} while( reader.NextResult() );
					if( resultCnt==1 )
					{
						PushIndent("        ");
						CreatePrimaryFetcher();
						PopIndent();
					}
				}
			}
		}
	}

	public class SelectCommandDefinition
	{
		public string ClassName;
		public string CommandText;
		public IEnumerable<ParameterNameAndType> Parameters;
	}

	public class ParameterNameAndType
	{
		readonly string _name;
		readonly Type _type;
		readonly SqlDbType _sqlDbType;

		public ParameterNameAndType( string name, Type type, SqlDbType sqlDbType )
		{
			_name = name;
			_type = type;
			_sqlDbType = sqlDbType;
		}

		public string Name { get { return _name; } }
		public Type Type { get { return _type; } }
		public SqlDbType SqlDbType { get { return _sqlDbType; }}
	}

	public class ParameterNameAndTypeList : List<ParameterNameAndType>
	{
		public void Add( string parameterName, Type type, SqlDbType sqlDbType  )
		{
			Add( new ParameterNameAndType( parameterName, type, sqlDbType ) );
		}
	}

	void GenerateCommandClassContent( SelectCommandDefinition cmdDef, ClassContext cls )
	{
		GenerateCommandTextConstant( cmdDef.CommandText );

		GeneratePreparedCommandField();

		DeclareField( "_sqlCommand", "SqlCommand", @readonly:true );

		foreach( var param in cmdDef.Parameters )
		{
			DeclareField( "_param_"+param.Name, "SqlParameter", @readonly:true );
		}

		DeclareConstractor( cls, 
					parameters: new[] { new { Name="conn", Type="SqlConnection" } },
					body: () => { GenerateConstructorBody(cmdDef); } );
		GenerateDisposableMethods(cls);

		DeclareMethod( "Execute", "SqlDataReader", 
					parameters: cmdDef.Parameters.Select(p=> new { Name=p.Name, Type=p.Type.Name }),
					body: ()=>{ GenerateExecuteMethodBody(cmdDef); });
	}

	void GenerateDisposableMethods(ClassContext cls)
	{
		DeclareMethod( "Dispose", "void",access: "public",
					body: GenerateDisposableDisposeBody );
		DeclareFinalizer( cls,
					body: GenerateFinalizerBody );
		DeclareField( "_disposed", "bool" );
		DeclareMethod( "Dispose", "void",
					parameters: new[] { new { Name="disposing",Type="bool" } },
					body: GenerateDisposeBoolBody );
		DeclareMethod( "ThrowIfDisposed", "void", access:"private",
					body: GenerateThrowIfDisposedBody );	
	}

	public void GenerateCommandTextConstant( string commandText )
	{
		DeclareConst( "CommandText", "string", ()=>{
			using( BeginDisableIndent() ) { Write( ToVerbatimString(commandText) ); } } );
	}

	public void GeneratePreparedCommandField()
	{
		DeclareField( "_preparedCommand", "ConcurrentStack<SqlCommand>",
			@readonly: true, 
			@static:true, 
			initializer : ()=> { Write( "new ConcurrentStack<SqlCommand>()" ); } );
	}

	public void GenerateFetcher( string className,  DataTable schema, int resultCnt )
	{
		GenerateFetcherHead( resultCnt );
		GenerateFetcherBody(schema);
		GenerateFetcherTail();
	}

	public void GenerateFetcherBody( DataTable schema )
	{
		Generate( schema.Rows.Cast<DataRow>(), row=> {
			bool isAllowDbNull = (bool)row["AllowDbNull"];
			string columnName =(string) row["ColumnName"];
			int columnOrdinal = (int)row["ColumnOrdinal"];
			Type columnDataType = (Type)row["DataType"];
			GenerateFetchColumn( columnName, columnDataType, isAllowDbNull, columnOrdinal );
		});
	}

	public void GenerateResultSetStruct( string className, DataTable schema,int resultCnt )
	{
		DeclareStruct( string.Format("ResultSet{0}", resultCnt ), () => {
			Generate( schema.Rows.Cast<DataRow>(), CreateResultSetProperty );
		} );
	}

	public void CreateResultSetProperty( DataRow row )
	{
		var isAllowDbNull = (bool)row["AllowDbNull"];
		var dataType = (Type)row["DataType"];
		var columnName = (string) row["ColumnName"];
		CreateResultSetProperty( dataType, isAllowDbNull, columnName );
	}

	public void GenerateFetchColumn( string columnName, Type columnDataType, bool isAllowDbNull, int columnOrdinal )
	{
		string propertyName = ToPropertyName( columnName );
		string getterName = GetterOf(columnDataType);

		if( !isAllowDbNull )
		{
			GenerateFetchColumnNotNull( propertyName, columnOrdinal, getterName );
		}
		else
		{
			GenerateFetchColumnNullable( propertyName, columnDataType, columnOrdinal, getterName );
		}
	}

	public void GenerateConstructorBody(SelectCommandDefinition cmdDef)
	{
		var cmdParams = cmdDef.Parameters;
		WriteLine( "SqlCommand command;" );
		GenerateIfElse( ()=>{ Write( "!_preparedCommand.TryPop( out command )" ); },
			()=>{ GeneratePreparedCommandNotPopped(cmdParams);},
			()=>{ GeneratePreparedCommandPopped(cmdParams); } );
	}





	public void GenerateFinalizerBody()
	{
#>
Dispose(false);
<#+
	}

	public void GenerateDisposableDisposeBody()
	{
#>
Dispose(true);
<#+
	}

	public void GenerateDisposeBoolBody()
	{
#>
if( _disposed ) return;
if( disposing )
{
	_sqlCommand.Connection = null;
	_preparedCommand.Push( _sqlCommand );
	GC.SuppressFinalize( this );
}
_disposed = true;
<#+	
	}

	public void GenerateThrowIfDisposedBody()
	{
#>
if( _disposed ) throw new ObjectDisposedException(GetType().FullName);
<#+
	}

	public void GeneratePreparedCommandNotPopped( IEnumerable<ParameterNameAndType> cmdParams )
	{
#>
_sqlCommand = new SqlCommand( CommandText, conn ); 		
<#+	
		GenerateParameterCreate( cmdParams ); 
#>
_sqlCommand.Parameters.AddRange( 
    new [] { <#+ Generate( cmdParams, ", ", param=>{#>_param_<#=param.Name#><#+ });#> } );
<#+
	}

	public void GeneratePreparedCommandPopped( IEnumerable<ParameterNameAndType> cmdParams )
	{
#>
command.Connection = conn;
<#+	
		GenerateParameterCopy( cmdParams );	
#>
_sqlCommand = command;
<#+
	}

	public void GenerateParameterCreate( IEnumerable<ParameterNameAndType> cmdParams )
	{
		Generate( cmdParams, param=>{#>
_param_<#=param.Name#> = new SqlParameter( "<#=param.Name#>",SqlDbType.<#=param.SqlDbType#> );
<#+		
		});
	}

	public void GenerateParameterCopy( IEnumerable<ParameterNameAndType> cmdParams )
	{
		Generate( cmdParams, (param,index)=>{#>
_param_<#=param.Name#>= command.Parameters[<#=index#>];
<#+	});
	}

	public void GenerateExecuteMethodBody(SelectCommandDefinition cmdDef)
	{
#>
ThrowIfDisposed();
<#+
	Generate( cmdDef.Parameters,param=>{#>
_param_<#=param.Name#>.Value = <#=param.Name#>;
<#+ }); #>
return _sqlCommand.ExecuteReader( );
<#+
	}

	public void GenerateFetcherHead( int resultCnt )
	{
#>
public IEnumerable<ResultSet<#=resultCnt#>> Fetch<#=resultCnt#>( SqlDataReader reader )
{
    while( reader.Read() )
    {
        var record= new ResultSet<#=resultCnt#> 
        {
<#+
		PushIndent("            ");
	}

	public void GenerateFetcherTail( )
	{
		PopIndent();
#>
        };
        yield return record;
    }
}
<#+
	}

	public void GenerateFetchColumnNotNull(string propertyName, int columnOrdinal, string getterName )
	{
#>
<#=propertyName#>=reader.<#= getterName#>(<#=columnOrdinal#>),
<#+
	}

	public void GenerateFetchColumnNullable( string propertyName, Type columnDataType, int columnOrdinal, string getterName )
	{
#>
<#=propertyName#>= reader.IsDBNull(<#=columnOrdinal#>)
    ? default(<#=columnDataType#>)
    : reader.<#= getterName#>(<#=columnOrdinal#>),
<#+	
	}

	public void CreateResultSetProperty( Type dataType, bool isAllowDbNull, string columnName )
	{
#>
public <#=dataType#><#=isAllowDbNull && dataType!=typeof(string) ? "?" : ""#> <#=ToPropertyName( columnName )#> { get; internal set; }
<#+
	}

	public void CreatePrimaryFetcher()
	{
#>
public IEnumerable<ResultSet0> Fetch( SqlDataReader reader )
{
	return Fetch0( reader );
}
<#+
	}

	// ToPropertyName : string -> string
	//  converts SQL column name to C# Property name
	// ex
	//  hoge -> Hoge, hoge_id -> HogeId,
	//  HOGE -> Hoge, HOGE_ID -> HogeId
	// remarks
	//  (null) -> NoName, ""-> NoName
	public string ToPropertyName( string columnName )
	{
		if( string.IsNullOrEmpty(columnName) ) return "NoName";

		var nameParts = columnName.Split('_');
		return string.Join( "",nameParts.Select( 
			s =>
				s.Length > 1 
					? char.ToUpper( s[0] ) + s.Substring(1).ToLower() 
					: char.ToUpper( s[0] ).ToString() ) );
	}

	public static bool IsValidGetterParam( System.Reflection.MethodInfo m )
	{
		var p = m.GetParameters();
		if( p.Count()!=1 ) return false;
		return p[0].ParameterType == typeof( int ) ;
	}

	static Dictionary<Type,System.Reflection.MethodInfo > _getMethods =
			typeof(SqlDataReader).GetMethods()
				.Where( m=>m.Name.StartsWith("Get") )
				.Where( m=>!m.Name.StartsWith("GetSql") )
				.Where( m=>IsValidGetterParam(m) )
				.Where( 
					m=>m.Name!="GetOrdinal" 
					&& m.Name!="GetFieldType" 
					&& m.Name!="GetDataTypeName" 
					&& m.Name!="GetName"
					&& m.Name!="GetProviderSpecificValue"
					&& m.Name!="GetProviderSpecificFieldType" )
				.ToDictionary( m=>m.ReturnType );

	// GetterOf : Type -> string
	//  gets SqlDataReader field getter method name for specific Type
	public string GetterOf( Type dataType )
	{
		return _getMethods[dataType].Name;
	}
#>